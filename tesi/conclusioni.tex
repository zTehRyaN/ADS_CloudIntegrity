%	Elencare i risultati raggiunti e sottolinearne il valore. Parlare anche dell'avanzamento rispetto allo stato dell'arte
%	di cui sopra.

	Nell'ambito di questa attività è stato realizzato un set di API di supporto alla realizzazione di un protocollo per l'integrità dei dati su cloud. La progettazione ha dovuto tenere conto sia dei casi d'uso relativi a requisiti funzionali sia della possibilità di utilizzo dell'intera libreria in contesto concorrente. Oltre a ciò è stato deciso di prendere in considerazione anche altre specifiche come usabilità, prestazioni e sostenibilità, come già ampiamente discusso in fase di analisi. Lo studio teorico e la progettazione sono poi proseguite con lo scopo di realizzare una estensione delle API atta a consentirne la memorizzazione e gestione in persistenza.

\section{Problemi aperti e sviluppi futuri}

	\subsection{Limiti concettuali su Proof}
	
%		Discutere qui dei problemi relativi a ciò che è stato realizzato (se presenti) e a suoi limiti, accennando alla possibile
%		soluzione del prossimo paragrafo

		Concettualmente parlando, come si è già detto, la Proof rappresenta una struttura a se stante dalla struttura di partenza, a partire dal momento in cui viene creata. Si è inoltre sottolineato come in realtà non ci sia nessuna conoscenza dell'ADS da parte della Proof a posteriori, tanto più considerando il caso in cui l'ADS sia memorizzata in persistenza.
		Ebbene, nell'ambito dell'utilizzo delle librerie si vuole istanziare una Proof a partire da uno stato iniziale $ T_{0} $ della struttura. Successivamente alla ricezione e applicazione sull'ADS di blocchi di update, che può aver ricevuto, si vogliono riproporre tali aggiornamenti sulla Proof, parallelamente. Tuttavia l'attuale realizzazione consente questo solo nel caso in cui gli update riguardino aggiornamenti di chiavi già esistenti. Infatti update che aggiungono o cancellano chiavi, modificano la struttura, che, essendo inoltre randomica, può variare consistentemente nella sua interezza. Queste informazioni non sono più conosciute dalla Proof, dal momento che è una realtà ontologicamente indipendente, anche se sarebbero necessarie. Non è possibile per esempio sapere se il nodo \textit{HEAD} è variato, crescendo o decrescendo, rendendo inconsistente la stessa Proof, anche prima di applicare gli update.
	
	\subsection{Ipotesi di soluzione con Modello a ruoli}
	
%		Parlare qui della soluzione precedentemente accennata
	
		Una ipotesi di soluzione è stata ideata, ma non realizzata. Sarebbe interessante come sviluppo futuro attuarne la realizzazione.
		
%		DESCRIVERE LA SOLUZIONE da fogli
		L'idea parte dall'osservazione che nella Skip List Autenticata ogni nodo, in un particolare istante temporale, riveste un ruolo. Questo ruolo inoltre non è statico, ma può cambiare corrispondentemente ad un qualsiasi aggiornamento che comporti una aggiunta o una cancellazione. Dunque la soluzione prevede di eliminare l'assunto di dover creare una struttura a se stante, mantenendo tutte le informazioni necessarie all'interno della struttura principale, al solo costo di dover mantenere aggiornata questa struttura di ruoli. Gli algoritmi delle varie operazioni, di conseguenza, saranno dipendenti dal ruolo dei vari nodi toccati. Così facendo, gli aggiornamenti che arrivano in blocco all'ADS, indirettamente tengono aggiornate tutte le Proof presenti al suo interno, anche e soprattutto nei casi di aggiunta o cancellazione.
		I ruoli principali di cui tener conto sarebbero:
		\begin{itemize}
			\item \textbf{Head}. Rivestito in ogni istante da uno e un solo nodo, ovvero lo \textit{Start Node}. E' il punto di partenza per la generazione di Proof e per tutte le altre operazioni sull'ADS.
			\item \textbf{Tower}. Nodo che ha sopra di se un altro nodo.
			\item \textbf{Plateau}. Nodo che non ha nulla al di sopra di se.
			\item \textbf{Head<Proof>}. Nodo HEAD di riferimento per una particolare Proof, relativa ad un istante temporale precedente ad eventuali variazioni dell'ADS.
			\item \textbf{PathProof<Proof>}. Nodo presente nel path di una determinata Proof.
			\item \textbf{HashingNode<Proof>}. Nodo non presente nel path, ma necessario per ricostruzione del RootHash per una determinata Proof.
		\end{itemize}
		
	\subsection{Realizzazione progetto persistenza}
		
%		Sezione relativa agli sviluppi futuri in cui semplicemente si accenna alla realizzazione del progetto persistenza.
%		Magari eventualmente accennare alle tecnologie pensate.

	Infine, un ulteriore sviluppo futuro, potrebbe vedere la realizzazione e l'applicazione ad un caso reale del progetto di persistenza presentato nel corso di questa tesi. Infatti, sebbene questo sia stato condotto con particolare riferimento a \textit{Cassandra}, un DBMS non relazionale molto diffuso, in realtà con poche dovute accortezze è perfettamente replicabile per molti altre situazioni, risultando quasi totalmente indipendente dalla tecnologia adottata.